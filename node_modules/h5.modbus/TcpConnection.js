var inherits = require('util').inherits,
    Socket = require('net').Socket,
    Connection = require('./Connection');

var TcpConnection = module.exports = function(options)
{
  Connection.call(this);
  
  var me = this;
  
  this.connecting = false;
  this.connected = false;
  this.socket = null;
  this.shouldReconnect = true;
  this.connectionAttempts = 0;
  
  this.setUpOptions(options || {});
  this.setUpReconnectHandler();
  
  if (this.autoConnect)
  {
    this.connect();
  }
};

inherits(TcpConnection, Connection);

TcpConnection.prototype.isConnected = function()
{
  return this.connected;
};

TcpConnection.prototype.connect = function()
{
  if (this.connecting || this.isConnected())
  {
    return;
  }

  clearTimeout(this.reconnectTimer);
  this.reconnectTimer = null;
  
  this.connecting = true;
  this.shouldReconnect = true;
  this.connectionAttempts += 1;
  
  this.setUpSocket();
  
  this.socket.connect(this.port, this.host);
};

TcpConnection.prototype.disconnect = function(shouldReconnect)
{
  this.shouldReconnect = shouldReconnect === true;
  
  if (this.socket)
  {
    this.socket.destroy();
    this.socket = null;
    this.connected = false;
  }
};

TcpConnection.prototype.write = function(data)
{
  if (!this.isConnected())
  {
    return;
  }
  
  try
  {
    this.socket.write(data);
  }
  catch (err)
  {
    this.emit('error', err);
  }
};

/**
 * @private
 */
TcpConnection.prototype.setUpOptions = function(options)
{
  this.host = typeof options.host === 'string' && options.host.length
    ? options.host
    : '127.0.0.1';

  this.port = typeof options.port === 'number' && options.port > 0
    ? options.port
    : 502;
  
  this.autoConnect =
    typeof options.autoConnect !== 'undefined' && options.autoConnect;
  
  this.autoReconnect =
    typeof options.autoReconnect === 'undefined' || options.autoReconnect;

  this.minConnectTime =
    typeof options.minConnectTime === 'number' && options.minConnectTime > 0
      ? options.minConnectTime
      : 2500;

  this.maxReconnectTime =
    typeof options.maxReconnectTime === 'number' && options.maxReconnectTime > 0
      ? options.maxReconnectTime
      : 5000;
  
  for (var event in (options.listeners || {}))
  {
    this.on(event, options.listeners[event]);
  }
};

/**
 * @private
 */
TcpConnection.prototype.setUpReconnectHandler = function()
{
  var me = this;
  
  this.on('disconnect', function()
  {
    if (me.autoReconnect && me.shouldReconnect)
    {
      var reconnectTime = 500 * me.connectionAttempts;

      if (reconnectTime > me.maxReconnectTime)
      {
        reconnectTime = me.maxReconnectTime;
      }

      me.reconnectTimer = setTimeout(me.connect.bind(me), reconnectTime);
    }
  });
};

/**
 * @private
 */
TcpConnection.prototype.setUpSocket = function()
{
  var me = this;
  
  if (me.socket)
  {
    me.socket.destroy();
  }

  me.socket = new Socket();
  me.socket.setNoDelay(true);
  me.socket.setKeepAlive(true);
  me.socket.on('data', function(data) { me.emit('data', data); });
  me.socket.on('error', function(err) { me.emit('error', err); });
  me.socket.on('connect', function()
  {
    me.connecting = false;
    me.connected = true;

    clearTimeout(me.minConnectTimeTimer);
    me.minConnectTimeTimer = setTimeout(
      function()
      {
        me.connectionAttempts = 0;
        me.minConnectTimeTimer = null;
      },
      me.minConnectTime
    );

    me.emit('connect');
  });
  me.socket.on('close', function(hadError)
  {
    clearTimeout(me.minConnectTimeTimer);
    me.minConnectTimeTimer = null;

    me.connecting = false;
    me.connected = false;

    me.emit('disconnect', hadError);
  });
};
