var inherits = require('util').inherits;
var buffers = require('h5.buffers');
var Transport = require('./Transport');
var exceptions = require('./exceptions');

module.exports = AsciiTransport;

var FRAME_START = 0x3A;
var FRAME_CR = 0x0D;
var FRAME_LF = 0x0A;

function AsciiTransport(connection, options)
{
  Transport.call(this);

  this.reader = new buffers.BufferQueueReader();
  this.timeouts = 0;
  this.currentRequest = null;

  this.setUpOptions(options);
  this.setUpConnection(connection);
}

inherits(AsciiTransport, Transport);

AsciiTransport.prototype.request = function(pdu, handler, timeout)
{
  if (!this.currentRequest)
  {
    throw new Error("Can not send another request while the previous has not yet completed.");
  }

  this.connection.write(this.frame(pdu));

  this.currentRequest = {
    handler: handler,
    timeout: this.createTimeoutHandler(timeout)
  };
};

AsciiTransport.prototype.setUpOptions = function(options)
{
  this.timeout = 500;
  this.maxTimeouts = 10;

  if (typeof options.timeout === 'number' && options.timeout > 0)
  {
    this.timeout = options.timeout;
  }

  if (typeof options.maxTimeouts === 'number' && options.maxTimeouts > 0)
  {
    this.maxTimeouts = options.maxTimeouts;
  }

  for (var event in (options.listeners || {}))
  {
    this.on(event, options.listeners[event]);
  }
};

AsciiTransport.prototype.setUpConnection = function(connection)
{
  connection.on('data', this.onData.bind(this));

  this.connection = connection;
};

AsciiTransport.prototype.createTimeoutHandler = function(timeout)
{
  var me = this;

  function handleTimeout()
  {
    if (!me.currentRequest)
    {
      return;
    }

    var request = me.currentRequest;
    me.currentRequest = null;

    process.nextTick(function()
    {
      me.handleResponse(request.handler, exceptions.ResponseTimeout(), null);
    });

    if (++me.timeouts === me.maxTimeouts)
    {
      me.timeouts = 0;

      me.connection.disconnect(true);
    }
  }

  setTimeout(handleTimeout, timeout || this.timeout);
};

AsciiTransport.prototype.frame = function(pdu)
{
  var frame = new Buffer(this.calculateAduLengthFor(pdu));
  var i = 0;

  frame[i++] = FRAME_START;

  for (var b = 0; b < pdu.length; ++b)
  {
    frame[i++] = this.encodeNibble(this.high(pdu[b]));
    frame[i++] = this.encodeNibble(this.low(pdu[b]));
  }

  var chksum = this.lrc(pdu);

  frame[i++] = this.encodeNibble(this.high(chksum));
  frame[i++] = this.encodeNibble(this.low(chksum));

  frame[i++] = FRAME_CR;
  frame[i] = FRAME_LF;

  return frame;
};

AsciiTransport.prototype.lrc = function(buffer)
{
  var result = 0;

  for (var i = 0; i < buffer.length; ++i)
  {
    result += (buffer[i] & 0xFF);
  }

  return ((result ^ 0xFF) + 1) & 0xFF;
};

AsciiTransport.prototype.calculateAduLengthFor = function(pduBuffer)
{
  return 5 + pduBuffer.length * 2;
};

AsciiTransport.prototype.high = function(byte)
{
  return ((byte & 0xF0) >>> 4) & 0xFF;
};

AsciiTransport.prototype.low = function(byte)
{
  return ((byte & 0x0F) >>> 0) & 0xFF;
};

AsciiTransport.prototype.encodeNibble = function(nibble)
{
  return nibble + (nibble < 10 ? 48 : 55);
};

AsciiTransport.prototype.decodeNibble = function(nibble)
{
  return nibble - (nibble < 65 ? 48 : 55);
};

AsciiTransport.prototype.decodeByte = function(highNibble, lowNibble)
{
  return (this.decodeNibble(highNibble) << 4)
    + (this.decodeNibble(lowNibble) << 0)
};

AsciiTransport.prototype.decodeBytes = function(bytes)
{
  var result = [];

  while (bytes.length)
  {
    result.push(this.decodeByte(bytes.shift(), bytes.shift()));
  }

  return result;
};

AsciiTransport.prototype.onData = function(data)
{
  if (!this.currentRequest)
  {
    return;
  }

  if (this.isInvalidChunk(data))
  {
    this.emit('error', exceptions.InvalidResponseData());
  }
  else
  {
    this.reader.pushBuffer(data);

    if (this.endsWithCrLf(data))
    {
      this.handleFrameData();
    }
  }
};

AsciiTransport.prototype.isInvalidChunk = function(data)
{
  return this.reader.length === 0 && data[0] !== FRAME_START;
};

AsciiTransport.prototype.endsWithCrLf = function(data)
{
  return data.length >= 2
    && data[data.length - 2] === FRAME_CR
    && data[data.length - 1] === FRAME_LF;
};

AsciiTransport.prototype.handleFrameData = function()
{
  var request = this.currentRequest;
  this.currentRequest = null;

  clearTimeout(request.timeout);

  this.timeouts = 0;

  this.reader.shiftByte();

  var frame = this.decodeBytes(this.reader.shiftBytes(this.reader.length - 2));
  var chksum = frame.pop();

  this.reader.skip(this.reader.length);

  var error = null;
  var data = null;

  if (this.lrc(frame) !== chksum)
  {
    error = exceptions.InvalidChecksum();
  }
  else
  {
    var unit = frame.shift();
    var fn = frame.shift();

    if (fn > 0x80)
    {
      var errno = frame.shift();

      error = errno in exceptions
        ? exceptions[errno]()
        : new Error("Unknown error code: " + errno);
    }
    else
    {
      data = new Buffer(frame);
    }
  }

  this.handleResponse(request.handler, error, data);
};


AsciiTransport.prototype.handleResponse = function(handler, error, data)
{
  if (typeof handler !== 'function')
  {
    return;
  }

  try
  {
    handler(error, data);
  }
  catch (err)
  {
    this.emit('error', err);
  }
};
